### 完全背包和01背包的区别

| 特性 | 01背包问题 | 完全背包问题 |
|------|------------|--------------|
| **物品选择次数** | 每个物品只能选择一次（0或1次） | 每个物品可以选择多次（无限次） |
| **状态转移方程** | `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])` | `dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])` |
| **内层循环方向** | 从大到小（确保每个物品只选择一次） | 从小到大（允许每个物品多次选择） |
| **空间优化后的实现** | 内层循环从 `W` 到 `w[i]` | 内层循环从 `w[i]` 到 `W` |

### 转移公式

#### 01背包问题的转移公式

**状态定义：**
`dp[i][j]` 表示前 `i` 个物品在背包容量为 `j` 时的最大价值。

**状态转移方程：**
```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
```
- `dp[i-1][j]`：不选择第 `i` 个物品时的最大价值。
- `dp[i-1][j-w[i]] + v[i]`：选择第 `i` 个物品时的最大价值。

**空间优化后的实现：**
```python
for i in range(1, n+1):
    for j in range(W, w[i-1]-1, -1):
        dp[j] = max(dp[j], dp[j-w[i-1]] + v[i-1])
```

#### 完全背包问题的转移公式

**状态定义：**
`dp[i][j]` 表示前 `i` 个物品在背包容量为 `j` 时的最大价值。

**状态转移方程：**
```
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```
- `dp[i-1][j]`：不选择第 `i` 个物品时的最大价值。
- `dp[i][j-w[i]] + v[i]`：选择第 `i` 个物品时的最大价值。

**空间优化后的实现：**
```python
for i in range(1, n+1):
    for j in range(w[i-1], W+1):
        dp[j] = max(dp[j], dp[j-w[i-1]] + v[i-1])
```

### 示例

假设 `n = 3`, `W = 5`, `w = [1, 2, 3]`, `v = [1, 3, 4]`。

#### 01背包问题的结果

最终 `dp[5]` 的值为 `5`（选择物品1和物品3）。

#### 完全背包问题的结果

最终 `dp[5]` 的值为 `7`（选择物品2和物品2，或者物品1和物品1和物品3）。

### 总结

- **01背包问题**：每个物品只能选择一次，内层循环从大到小。
- **完全背包问题**：每个物品可以选择多次，内层循环从小到大。
- **转移公式**：两者在状态转移方程中有所不同，反映了物品选择的限制。